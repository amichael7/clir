package clir

import (
	"reflect"
	"errors"
	"runtime"
	"fmt"
)

// Action represents a function that gets calls when the command is called by
// the user
type Action struct {
	callback 	interface{}
	args		[]interface{}
}

func (a *Action) run() error {
	// Check whether the callback is a function
	v := reflect.ValueOf(a.callback)
	if v.Kind() != reflect.Func {
		return errors.New("not a function")
	}


	// detect cases where arguments provided is different
	// 		from the number requested
	// prevents reflect package from generating panic
	diff := reflect.TypeOf(a.callback).NumIn() - len(a.args)
	funcName := runtime.FuncForPC(v.Pointer()).Name()
	if diff < 0 {
		err := fmt.Sprintf("too many arguments provided to %s", funcName)
		return errors.New(err)
	}
	if diff > 0 {
		err := fmt.Sprintf("too many arguments provided to %s", funcName)
		return errors.New(err)
	}

	// Run the function
	vargs := make([]reflect.Value, len(a.args))
	for i, arg := range a.args {
		vargs[i] = reflect.ValueOf(arg)
	}

	// Return error generated by the function, if any
	res := v.Call(vargs)
	if v := res[0].Interface(); v != nil {
		err := v.(error)
		return err
	} else {
		return nil
	}
}